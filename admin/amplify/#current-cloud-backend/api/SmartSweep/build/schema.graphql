
enum OrderStatus {
  NEW
  DRIVING
  READY_FOR_PICKUP
  PICKED_UP
  COMPLETED
  ACCEPTED
  DECLINED_BY_WASTEPROVIDER
}

type OrderService @aws_iam @aws_api_key {
  id: ID!
  quantity: Int!
  Service: Service
  orderID: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
  orderServiceServiceId: ID
}

type Order @aws_iam @aws_api_key {
  id: ID!
  userID: ID!
  WasteProvider: WasteProvider
  total: Float!
  status: OrderStatus!
  OrderServices(filter: ModelOrderServiceFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelOrderServiceConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
  orderWasteProviderId: ID
}

type BasketService @aws_iam @aws_api_key {
  id: ID!
  quantity: Int!
  basketID: ID!
  Services(filter: ModelBasketServiceServiceFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketServiceServiceConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type Service @aws_iam @aws_api_key {
  id: ID!
  name: String!
  image: String
  description: String
  price: Float!
  wasteproviderID: ID!
  basketservices(filter: ModelBasketServiceServiceFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketServiceServiceConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type WasteProvider @aws_iam @aws_api_key {
  id: ID!
  name: String!
  image: String!
  deliveryFee: Float!
  minDeliveryTime: Int!
  maxDeliveryTime: Int!
  rating: Float
  address: String!
  lat: Float!
  lng: Float!
  Services(filter: ModelServiceFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelServiceConnection
  Baskets(filter: ModelBasketFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketConnection
  adminSub: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type Basket @aws_iam @aws_api_key {
  id: ID!
  BasketServices(filter: ModelBasketServiceFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketServiceConnection
  userID: ID!
  wasteproviderID: ID!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type User @aws_iam @aws_api_key {
  id: ID!
  name: String!
  address: String!
  lat: Float!
  lng: Float!
  Orders(filter: ModelOrderFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelOrderConnection
  Baskets(filter: ModelBasketFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBasketConnection
  sub: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type BasketServiceService @aws_iam @aws_api_key {
  id: ID!
  basketServiceId: ID!
  serviceId: ID!
  basketService: BasketService!
  service: Service!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelOrderServiceConnection @aws_api_key @aws_iam {
  items: [OrderService]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelOrderServiceFilterInput {
  id: ModelIDInput
  quantity: ModelIntInput
  orderID: ModelIDInput
  and: [ModelOrderServiceFilterInput]
  or: [ModelOrderServiceFilterInput]
  not: ModelOrderServiceFilterInput
  orderServiceServiceId: ModelIDInput
}

type Query {
  getOrderService(id: ID!): OrderService @aws_api_key @aws_iam
  listOrderServices(filter: ModelOrderServiceFilterInput, limit: Int, nextToken: String): ModelOrderServiceConnection @aws_api_key @aws_iam
  syncOrderServices(filter: ModelOrderServiceFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelOrderServiceConnection @aws_api_key @aws_iam
  orderServicesByOrderID(orderID: ID!, sortDirection: ModelSortDirection, filter: ModelOrderServiceFilterInput, limit: Int, nextToken: String): ModelOrderServiceConnection @aws_api_key @aws_iam
  getOrder(id: ID!): Order @aws_api_key @aws_iam
  listOrders(filter: ModelOrderFilterInput, limit: Int, nextToken: String): ModelOrderConnection @aws_api_key @aws_iam
  syncOrders(filter: ModelOrderFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelOrderConnection @aws_api_key @aws_iam
  ordersByUserID(userID: ID!, sortDirection: ModelSortDirection, filter: ModelOrderFilterInput, limit: Int, nextToken: String): ModelOrderConnection @aws_api_key @aws_iam
  getBasketService(id: ID!): BasketService @aws_api_key @aws_iam
  listBasketServices(filter: ModelBasketServiceFilterInput, limit: Int, nextToken: String): ModelBasketServiceConnection @aws_api_key @aws_iam
  syncBasketServices(filter: ModelBasketServiceFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelBasketServiceConnection @aws_api_key @aws_iam
  basketServicesByBasketID(basketID: ID!, sortDirection: ModelSortDirection, filter: ModelBasketServiceFilterInput, limit: Int, nextToken: String): ModelBasketServiceConnection @aws_api_key @aws_iam
  getService(id: ID!): Service @aws_api_key @aws_iam
  listServices(filter: ModelServiceFilterInput, limit: Int, nextToken: String): ModelServiceConnection @aws_api_key @aws_iam
  syncServices(filter: ModelServiceFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelServiceConnection @aws_api_key @aws_iam
  servicesByWasteproviderID(wasteproviderID: ID!, sortDirection: ModelSortDirection, filter: ModelServiceFilterInput, limit: Int, nextToken: String): ModelServiceConnection @aws_api_key @aws_iam
  getWasteProvider(id: ID!): WasteProvider @aws_api_key @aws_iam
  listWasteProviders(filter: ModelWasteProviderFilterInput, limit: Int, nextToken: String): ModelWasteProviderConnection @aws_api_key @aws_iam
  syncWasteProviders(filter: ModelWasteProviderFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelWasteProviderConnection @aws_api_key @aws_iam
  getBasket(id: ID!): Basket @aws_api_key @aws_iam
  listBaskets(filter: ModelBasketFilterInput, limit: Int, nextToken: String): ModelBasketConnection @aws_api_key @aws_iam
  syncBaskets(filter: ModelBasketFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelBasketConnection @aws_api_key @aws_iam
  basketsByUserID(userID: ID!, sortDirection: ModelSortDirection, filter: ModelBasketFilterInput, limit: Int, nextToken: String): ModelBasketConnection @aws_api_key @aws_iam
  basketsByWasteproviderID(wasteproviderID: ID!, sortDirection: ModelSortDirection, filter: ModelBasketFilterInput, limit: Int, nextToken: String): ModelBasketConnection @aws_api_key @aws_iam
  getUser(id: ID!): User @aws_api_key @aws_iam
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection @aws_api_key @aws_iam
  syncUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelUserConnection @aws_api_key @aws_iam
  getBasketServiceService(id: ID!): BasketServiceService @aws_api_key @aws_iam
  listBasketServiceServices(filter: ModelBasketServiceServiceFilterInput, limit: Int, nextToken: String): ModelBasketServiceServiceConnection @aws_api_key @aws_iam
  syncBasketServiceServices(filter: ModelBasketServiceServiceFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelBasketServiceServiceConnection @aws_api_key @aws_iam
  basketServiceServicesByBasketServiceId(basketServiceId: ID!, sortDirection: ModelSortDirection, filter: ModelBasketServiceServiceFilterInput, limit: Int, nextToken: String): ModelBasketServiceServiceConnection @aws_api_key @aws_iam
  basketServiceServicesByServiceId(serviceId: ID!, sortDirection: ModelSortDirection, filter: ModelBasketServiceServiceFilterInput, limit: Int, nextToken: String): ModelBasketServiceServiceConnection @aws_api_key @aws_iam
}

input ModelOrderServiceConditionInput {
  quantity: ModelIntInput
  orderID: ModelIDInput
  and: [ModelOrderServiceConditionInput]
  or: [ModelOrderServiceConditionInput]
  not: ModelOrderServiceConditionInput
  orderServiceServiceId: ModelIDInput
}

input CreateOrderServiceInput {
  id: ID
  quantity: Int!
  orderID: ID!
  _version: Int
  orderServiceServiceId: ID
}

input UpdateOrderServiceInput {
  id: ID!
  quantity: Int
  orderID: ID
  _version: Int
  orderServiceServiceId: ID
}

input DeleteOrderServiceInput {
  id: ID!
  _version: Int
}

type Mutation {
  createOrderService(input: CreateOrderServiceInput!, condition: ModelOrderServiceConditionInput): OrderService @aws_api_key @aws_iam
  updateOrderService(input: UpdateOrderServiceInput!, condition: ModelOrderServiceConditionInput): OrderService @aws_api_key @aws_iam
  deleteOrderService(input: DeleteOrderServiceInput!, condition: ModelOrderServiceConditionInput): OrderService @aws_api_key @aws_iam
  createOrder(input: CreateOrderInput!, condition: ModelOrderConditionInput): Order @aws_api_key @aws_iam
  updateOrder(input: UpdateOrderInput!, condition: ModelOrderConditionInput): Order @aws_api_key @aws_iam
  deleteOrder(input: DeleteOrderInput!, condition: ModelOrderConditionInput): Order @aws_api_key @aws_iam
  createBasketService(input: CreateBasketServiceInput!, condition: ModelBasketServiceConditionInput): BasketService @aws_api_key @aws_iam
  updateBasketService(input: UpdateBasketServiceInput!, condition: ModelBasketServiceConditionInput): BasketService @aws_api_key @aws_iam
  deleteBasketService(input: DeleteBasketServiceInput!, condition: ModelBasketServiceConditionInput): BasketService @aws_api_key @aws_iam
  createService(input: CreateServiceInput!, condition: ModelServiceConditionInput): Service @aws_api_key @aws_iam
  updateService(input: UpdateServiceInput!, condition: ModelServiceConditionInput): Service @aws_api_key @aws_iam
  deleteService(input: DeleteServiceInput!, condition: ModelServiceConditionInput): Service @aws_api_key @aws_iam
  createWasteProvider(input: CreateWasteProviderInput!, condition: ModelWasteProviderConditionInput): WasteProvider @aws_api_key @aws_iam
  updateWasteProvider(input: UpdateWasteProviderInput!, condition: ModelWasteProviderConditionInput): WasteProvider @aws_api_key @aws_iam
  deleteWasteProvider(input: DeleteWasteProviderInput!, condition: ModelWasteProviderConditionInput): WasteProvider @aws_api_key @aws_iam
  createBasket(input: CreateBasketInput!, condition: ModelBasketConditionInput): Basket @aws_api_key @aws_iam
  updateBasket(input: UpdateBasketInput!, condition: ModelBasketConditionInput): Basket @aws_api_key @aws_iam
  deleteBasket(input: DeleteBasketInput!, condition: ModelBasketConditionInput): Basket @aws_api_key @aws_iam
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User @aws_api_key @aws_iam
  createBasketServiceService(input: CreateBasketServiceServiceInput!, condition: ModelBasketServiceServiceConditionInput): BasketServiceService @aws_api_key @aws_iam
  updateBasketServiceService(input: UpdateBasketServiceServiceInput!, condition: ModelBasketServiceServiceConditionInput): BasketServiceService @aws_api_key @aws_iam
  deleteBasketServiceService(input: DeleteBasketServiceServiceInput!, condition: ModelBasketServiceServiceConditionInput): BasketServiceService @aws_api_key @aws_iam
}

input ModelSubscriptionOrderServiceFilterInput {
  id: ModelSubscriptionIDInput
  quantity: ModelSubscriptionIntInput
  orderID: ModelSubscriptionIDInput
  and: [ModelSubscriptionOrderServiceFilterInput]
  or: [ModelSubscriptionOrderServiceFilterInput]
}

type Subscription {
  onCreateOrderService(filter: ModelSubscriptionOrderServiceFilterInput): OrderService @aws_subscribe(mutations: ["createOrderService"]) @aws_api_key @aws_iam
  onUpdateOrderService(filter: ModelSubscriptionOrderServiceFilterInput): OrderService @aws_subscribe(mutations: ["updateOrderService"]) @aws_api_key @aws_iam
  onDeleteOrderService(filter: ModelSubscriptionOrderServiceFilterInput): OrderService @aws_subscribe(mutations: ["deleteOrderService"]) @aws_api_key @aws_iam
  onCreateOrder(filter: ModelSubscriptionOrderFilterInput): Order @aws_subscribe(mutations: ["createOrder"]) @aws_api_key @aws_iam
  onUpdateOrder(filter: ModelSubscriptionOrderFilterInput): Order @aws_subscribe(mutations: ["updateOrder"]) @aws_api_key @aws_iam
  onDeleteOrder(filter: ModelSubscriptionOrderFilterInput): Order @aws_subscribe(mutations: ["deleteOrder"]) @aws_api_key @aws_iam
  onCreateBasketService(filter: ModelSubscriptionBasketServiceFilterInput): BasketService @aws_subscribe(mutations: ["createBasketService"]) @aws_api_key @aws_iam
  onUpdateBasketService(filter: ModelSubscriptionBasketServiceFilterInput): BasketService @aws_subscribe(mutations: ["updateBasketService"]) @aws_api_key @aws_iam
  onDeleteBasketService(filter: ModelSubscriptionBasketServiceFilterInput): BasketService @aws_subscribe(mutations: ["deleteBasketService"]) @aws_api_key @aws_iam
  onCreateService(filter: ModelSubscriptionServiceFilterInput): Service @aws_subscribe(mutations: ["createService"]) @aws_api_key @aws_iam
  onUpdateService(filter: ModelSubscriptionServiceFilterInput): Service @aws_subscribe(mutations: ["updateService"]) @aws_api_key @aws_iam
  onDeleteService(filter: ModelSubscriptionServiceFilterInput): Service @aws_subscribe(mutations: ["deleteService"]) @aws_api_key @aws_iam
  onCreateWasteProvider(filter: ModelSubscriptionWasteProviderFilterInput): WasteProvider @aws_subscribe(mutations: ["createWasteProvider"]) @aws_api_key @aws_iam
  onUpdateWasteProvider(filter: ModelSubscriptionWasteProviderFilterInput): WasteProvider @aws_subscribe(mutations: ["updateWasteProvider"]) @aws_api_key @aws_iam
  onDeleteWasteProvider(filter: ModelSubscriptionWasteProviderFilterInput): WasteProvider @aws_subscribe(mutations: ["deleteWasteProvider"]) @aws_api_key @aws_iam
  onCreateBasket(filter: ModelSubscriptionBasketFilterInput): Basket @aws_subscribe(mutations: ["createBasket"]) @aws_api_key @aws_iam
  onUpdateBasket(filter: ModelSubscriptionBasketFilterInput): Basket @aws_subscribe(mutations: ["updateBasket"]) @aws_api_key @aws_iam
  onDeleteBasket(filter: ModelSubscriptionBasketFilterInput): Basket @aws_subscribe(mutations: ["deleteBasket"]) @aws_api_key @aws_iam
  onCreateUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: ["createUser"]) @aws_api_key @aws_iam
  onUpdateUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: ["updateUser"]) @aws_api_key @aws_iam
  onDeleteUser(filter: ModelSubscriptionUserFilterInput): User @aws_subscribe(mutations: ["deleteUser"]) @aws_api_key @aws_iam
  onCreateBasketServiceService(filter: ModelSubscriptionBasketServiceServiceFilterInput): BasketServiceService @aws_subscribe(mutations: ["createBasketServiceService"]) @aws_api_key @aws_iam
  onUpdateBasketServiceService(filter: ModelSubscriptionBasketServiceServiceFilterInput): BasketServiceService @aws_subscribe(mutations: ["updateBasketServiceService"]) @aws_api_key @aws_iam
  onDeleteBasketServiceService(filter: ModelSubscriptionBasketServiceServiceFilterInput): BasketServiceService @aws_subscribe(mutations: ["deleteBasketServiceService"]) @aws_api_key @aws_iam
}

type ModelOrderConnection @aws_api_key @aws_iam {
  items: [Order]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelOrderStatusInput {
  eq: OrderStatus
  ne: OrderStatus
}

input ModelOrderFilterInput {
  id: ModelIDInput
  userID: ModelIDInput
  total: ModelFloatInput
  status: ModelOrderStatusInput
  and: [ModelOrderFilterInput]
  or: [ModelOrderFilterInput]
  not: ModelOrderFilterInput
  orderWasteProviderId: ModelIDInput
}

input ModelOrderConditionInput {
  userID: ModelIDInput
  total: ModelFloatInput
  status: ModelOrderStatusInput
  and: [ModelOrderConditionInput]
  or: [ModelOrderConditionInput]
  not: ModelOrderConditionInput
  orderWasteProviderId: ModelIDInput
}

input CreateOrderInput {
  id: ID
  userID: ID!
  total: Float!
  status: OrderStatus!
  _version: Int
  orderWasteProviderId: ID
}

input UpdateOrderInput {
  id: ID!
  userID: ID
  total: Float
  status: OrderStatus
  _version: Int
  orderWasteProviderId: ID
}

input DeleteOrderInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionOrderFilterInput {
  id: ModelSubscriptionIDInput
  userID: ModelSubscriptionIDInput
  total: ModelSubscriptionFloatInput
  status: ModelSubscriptionStringInput
  and: [ModelSubscriptionOrderFilterInput]
  or: [ModelSubscriptionOrderFilterInput]
}

type ModelBasketServiceConnection @aws_api_key @aws_iam {
  items: [BasketService]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelBasketServiceFilterInput {
  id: ModelIDInput
  quantity: ModelIntInput
  basketID: ModelIDInput
  and: [ModelBasketServiceFilterInput]
  or: [ModelBasketServiceFilterInput]
  not: ModelBasketServiceFilterInput
}

input ModelBasketServiceConditionInput {
  quantity: ModelIntInput
  basketID: ModelIDInput
  and: [ModelBasketServiceConditionInput]
  or: [ModelBasketServiceConditionInput]
  not: ModelBasketServiceConditionInput
}

input CreateBasketServiceInput {
  id: ID
  quantity: Int!
  basketID: ID!
  _version: Int
}

input UpdateBasketServiceInput {
  id: ID!
  quantity: Int
  basketID: ID
  _version: Int
}

input DeleteBasketServiceInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionBasketServiceFilterInput {
  id: ModelSubscriptionIDInput
  quantity: ModelSubscriptionIntInput
  basketID: ModelSubscriptionIDInput
  and: [ModelSubscriptionBasketServiceFilterInput]
  or: [ModelSubscriptionBasketServiceFilterInput]
}

type ModelServiceConnection @aws_api_key @aws_iam {
  items: [Service]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelServiceFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  image: ModelStringInput
  description: ModelStringInput
  price: ModelFloatInput
  wasteproviderID: ModelIDInput
  and: [ModelServiceFilterInput]
  or: [ModelServiceFilterInput]
  not: ModelServiceFilterInput
}

input ModelServiceConditionInput {
  name: ModelStringInput
  image: ModelStringInput
  description: ModelStringInput
  price: ModelFloatInput
  wasteproviderID: ModelIDInput
  and: [ModelServiceConditionInput]
  or: [ModelServiceConditionInput]
  not: ModelServiceConditionInput
}

input CreateServiceInput {
  id: ID
  name: String!
  image: String
  description: String
  price: Float!
  wasteproviderID: ID!
  _version: Int
}

input UpdateServiceInput {
  id: ID!
  name: String
  image: String
  description: String
  price: Float
  wasteproviderID: ID
  _version: Int
}

input DeleteServiceInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionServiceFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  image: ModelSubscriptionStringInput
  description: ModelSubscriptionStringInput
  price: ModelSubscriptionFloatInput
  wasteproviderID: ModelSubscriptionIDInput
  and: [ModelSubscriptionServiceFilterInput]
  or: [ModelSubscriptionServiceFilterInput]
}

type ModelWasteProviderConnection @aws_api_key @aws_iam {
  items: [WasteProvider]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelWasteProviderFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  image: ModelStringInput
  deliveryFee: ModelFloatInput
  minDeliveryTime: ModelIntInput
  maxDeliveryTime: ModelIntInput
  rating: ModelFloatInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  adminSub: ModelStringInput
  and: [ModelWasteProviderFilterInput]
  or: [ModelWasteProviderFilterInput]
  not: ModelWasteProviderFilterInput
}

input ModelWasteProviderConditionInput {
  name: ModelStringInput
  image: ModelStringInput
  deliveryFee: ModelFloatInput
  minDeliveryTime: ModelIntInput
  maxDeliveryTime: ModelIntInput
  rating: ModelFloatInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  adminSub: ModelStringInput
  and: [ModelWasteProviderConditionInput]
  or: [ModelWasteProviderConditionInput]
  not: ModelWasteProviderConditionInput
}

input CreateWasteProviderInput {
  id: ID
  name: String!
  image: String!
  deliveryFee: Float!
  minDeliveryTime: Int!
  maxDeliveryTime: Int!
  rating: Float
  address: String!
  lat: Float!
  lng: Float!
  adminSub: String
  _version: Int
}

input UpdateWasteProviderInput {
  id: ID!
  name: String
  image: String
  deliveryFee: Float
  minDeliveryTime: Int
  maxDeliveryTime: Int
  rating: Float
  address: String
  lat: Float
  lng: Float
  adminSub: String
  _version: Int
}

input DeleteWasteProviderInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionWasteProviderFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  image: ModelSubscriptionStringInput
  deliveryFee: ModelSubscriptionFloatInput
  minDeliveryTime: ModelSubscriptionIntInput
  maxDeliveryTime: ModelSubscriptionIntInput
  rating: ModelSubscriptionFloatInput
  address: ModelSubscriptionStringInput
  lat: ModelSubscriptionFloatInput
  lng: ModelSubscriptionFloatInput
  adminSub: ModelSubscriptionStringInput
  and: [ModelSubscriptionWasteProviderFilterInput]
  or: [ModelSubscriptionWasteProviderFilterInput]
}

type ModelBasketConnection @aws_iam @aws_api_key {
  items: [Basket]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelBasketFilterInput {
  id: ModelIDInput
  userID: ModelIDInput
  wasteproviderID: ModelIDInput
  and: [ModelBasketFilterInput]
  or: [ModelBasketFilterInput]
  not: ModelBasketFilterInput
}

input ModelBasketConditionInput {
  userID: ModelIDInput
  wasteproviderID: ModelIDInput
  and: [ModelBasketConditionInput]
  or: [ModelBasketConditionInput]
  not: ModelBasketConditionInput
}

input CreateBasketInput {
  id: ID
  userID: ID!
  wasteproviderID: ID!
  _version: Int
}

input UpdateBasketInput {
  id: ID!
  userID: ID
  wasteproviderID: ID
  _version: Int
}

input DeleteBasketInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionBasketFilterInput {
  id: ModelSubscriptionIDInput
  userID: ModelSubscriptionIDInput
  wasteproviderID: ModelSubscriptionIDInput
  and: [ModelSubscriptionBasketFilterInput]
  or: [ModelSubscriptionBasketFilterInput]
}

type ModelUserConnection @aws_api_key @aws_iam {
  items: [User]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelUserFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  sub: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

input ModelUserConditionInput {
  name: ModelStringInput
  address: ModelStringInput
  lat: ModelFloatInput
  lng: ModelFloatInput
  sub: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
}

input CreateUserInput {
  id: ID
  name: String!
  address: String!
  lat: Float!
  lng: Float!
  sub: String!
  _version: Int
}

input UpdateUserInput {
  id: ID!
  name: String
  address: String
  lat: Float
  lng: Float
  sub: String
  _version: Int
}

input DeleteUserInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionUserFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  address: ModelSubscriptionStringInput
  lat: ModelSubscriptionFloatInput
  lng: ModelSubscriptionFloatInput
  sub: ModelSubscriptionStringInput
  and: [ModelSubscriptionUserFilterInput]
  or: [ModelSubscriptionUserFilterInput]
}

type ModelBasketServiceServiceConnection @aws_iam @aws_api_key {
  items: [BasketServiceService]!
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelBasketServiceServiceFilterInput {
  id: ModelIDInput
  basketServiceId: ModelIDInput
  serviceId: ModelIDInput
  and: [ModelBasketServiceServiceFilterInput]
  or: [ModelBasketServiceServiceFilterInput]
  not: ModelBasketServiceServiceFilterInput
}

input ModelBasketServiceServiceConditionInput {
  basketServiceId: ModelIDInput
  serviceId: ModelIDInput
  and: [ModelBasketServiceServiceConditionInput]
  or: [ModelBasketServiceServiceConditionInput]
  not: ModelBasketServiceServiceConditionInput
}

input CreateBasketServiceServiceInput {
  id: ID
  basketServiceId: ID!
  serviceId: ID!
  _version: Int
}

input UpdateBasketServiceServiceInput {
  id: ID!
  basketServiceId: ID
  serviceId: ID
  _version: Int
}

input DeleteBasketServiceServiceInput {
  id: ID!
  _version: Int
}

input ModelSubscriptionBasketServiceServiceFilterInput {
  id: ModelSubscriptionIDInput
  basketServiceId: ModelSubscriptionIDInput
  serviceId: ModelSubscriptionIDInput
  and: [ModelSubscriptionBasketServiceServiceFilterInput]
  or: [ModelSubscriptionBasketServiceServiceFilterInput]
}

